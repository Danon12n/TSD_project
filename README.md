# Скопировать коммит из одной ветки в другую

Команда `git cherry-pick <hash коммита>` берёт изменения, вносимые одним коммитом, и пытается повторно применить их в виде нового коммита в текущей ветке.
[Подробнее](https://www.atlassian.com/ru/git/tutorials/cherry-pick)

### Зачем это нужно? 

1. вы сделали пуш классной фичи в ветку prod. Работая над новой фичей в ветке dev вы обнаружили, что в вашей предыдущей фичи есть какаха. И вы такой. Оба, че делать? Исправляете это в ветке dev, делаете отдельный коммит и переносите его. Вы красафчик. 100кк вам платят не просто так 

2. в вашей команде есть другие челы. вы на бэке, а они на фронте. Т.к вы работаете в разных ветках, но с одними структурами данных, то они могут хапнуть ваш коммит к себе в ветку и спокойно работать 

## В каких случаях операцию копирования выполнить не получится?

если в ветке, куда вы хотите закинуть вишню, есть изменения, которые не закоммичены или не находятся в стэше 

# Дано 5 камитов в одной ветке

## Откатить коммит

Команда `git revert <hash коммита>` позволяет откатиться. Основной прикол в том, что она не удаляет историю, а такая: "шо там было до этого коммита? Я ща сама поищу изменения и сделаю новый коммит, который отменяет указанные изменения". Это самый безопасный прЕкол. Если вы фанат Гачи и вам подавай че пожестче, то можно заюзать `get reset <hash коммита>`. Это штучка не просто откатит вас, но и удалит историю изменений. Поговорим об этом подробнее. В git есть 3 ~~стула~~ "дерева". 1ое - Рабочий каталог (Чекает изменение файлов и каталогов); 2ое - Раздел проиндексированных файлов (работает после команды `git add`); 3ое - история коммитов (ну тут коммиты, да). В зависимости от параметров команды вы можете удалить ваще-ваще нахрен фсё, а можете перенести изменения в рабочий католог. `get reset` нельзя использовать в публичных репозиториях, т.к вы можете потерять работу. В локальном не рекомендуют, т.к вы можете потерять свои наработки)


[Подробнее revert](https://www.atlassian.com/git/tutorials/undoing-changes/git-revert)

[Подробнее reset](https://www.atlassian.com/ru/git/tutorials/undoing-changes/git-reset)

# Интерактивный rebase

Интерактивный rebase иногда называют «швейцарским армейским ножом» Git’а, поскольку он объединяет в себе так много различных инструментов для совершенно разных сценариев применения. При этом главным вариантом использования, без сомнения, является очистка **локальной** истории коммитов. Для чего его используют?
1. Редактирование бородатых коммитов
1. Объединение нескольких коммитов в один
1. Исправление ошибок

[Подробнее](https://habr.com/ru/companies/flant/articles/536698/)

# Чем merge отличается от rebase

Git Merge и Git Rebase преследуют одну и ту же цель. Они предназначены для интеграции изменений из одной ветки в другую. Хотя конечная цель одинаковая, принципы работы разные.

Слияние принимает содержимое ветки источника и объединяет их с целевой веткой. В этом процессе изменяется только целевая ветка. История исходных веток остается неизменной.

![image](https://user-images.githubusercontent.com/57214287/233868995-5eaf19bf-e06d-450a-8d7a-6e82643b36d8.png)

В отличие от слияния, перемещение перезаписывает историю, потому что она передает завершенную работу из одной ветки в другую. В процессе устраняется нежелательная история.

![image](https://user-images.githubusercontent.com/57214287/233869020-e08d0653-6190-44e6-b92b-1e60764b0931.png)

# Научиться Склеивать коммиты

Опа, `rebase` пригодился. Инструкция со старого доброго хабра, которые взяли статью из Омерики и перевели. Давайте предположим, что нужно объединить следующие выбранные коммиты в один:

![image](https://user-images.githubusercontent.com/57214287/233869301-4d05246e-2348-4047-bfb8-426eb8b1b4fa.png)

Процесс начинается с запуска сессии интерактивного rebase’а на коммите-предшественнике тех, что мы хотим изменить.

`$ git rebase -i 2b504bee`

Откроется окно редактора с историей коммитов, которые мы хотим объединить:

![image](https://user-images.githubusercontent.com/57214287/233869351-a487a268-dae5-4de3-8c0a-ce29ef7569b5.png)

Действию, которое мы собираемся произвести над коммитами, соответствует кодовое слово `squash`. В данном случае следует помнить лишь об одной тонкости: строка, помеченная «squash», будет объединена со строкой, которая находится выше нее. Именно поэтому на скриншоте выше я пометил словом squash строку №2 (она будет объединена со строкой №1).

Сохраните изменения и закройте окно редактора. Появится новое окно с просьбой ввести сообщение для нового, объединенного коммита:

![image](https://user-images.githubusercontent.com/57214287/233869382-b872a7c4-97d5-461e-99b5-97445798d236.png)\

Сохраните сообщение и закройте окно. Будет создан новый коммит, содержащий изменения обоих старых коммитов. Вуаля!

# Установить Git flow уметь работать и понимать смысл (feature, hotfix, release)

git-flow — это набор расширений git предоставляющий высокоуровневые операции над репозиторием для поддержки модели ветвления Vincent Driessen. [Тут проще прочитать статью](https://habr.com/ru/articles/106912/)

Кратко о модели. Она используется для выпуска продуктов. Есть 2 главные ветки: master и develop. 
1. Мы считаем ветку master главной. То есть, исходный код в ней должен находиться в состоянии production-ready в любой произвольный момент времени. 
2. Ветвь origin/develop мы считаем главной ветвью для разработки. Хранящийся в ней код в любой момент времени должен содержать самые последние изданные изменения, необходимые для следующего релиза. Эту ветку также можно назвать «интеграционной». Она служит источником для сборки автоматических ночных билдов.

Также есть 3 вспомогательные ветки: feature, hotfix, release
1. Ветви функциональностей (feature branches). Могут порождаться от: develop. Должны вливаться в: develop. Смысл существования ветви состоит в том, что она живёт так долго, сколько продолжается разработка данной функциональности (фичи). Когда работа в ветви завершена, последняя вливается обратно в главную ветвь разработки (что означает, что функциональность будет добавлена в грядущий релиз) или же удаляется (в случае неудачного эксперимента).
2. Ветви релизов (release branches). Могут порождаться от: develop. Должны вливаться в: master (а после в develop). Ветви используются для подготовки к выпуску новых версий продукта. Когда у вас уже почти все готово в develop вы создаете release, чтобы внести какие-то мелкие правки и подготовить ее для загрузки в master
3. hotfix. Могут порождаться от: master. Должны вливаться в: master (а после в develop или release). Если в последнем выпуске (ветке master) вы обнаружили какой-то кринж, то стоит создать ветку hotfix, чтобы остальная часть команды могла трудиться над develop. 

# DVC. Зачем нужен?

Вот у вас есть какой-то мега классный код, в основе которого лежит ML. У вас есть несколько скриптов и датасет. Скрипт работают последовательно (т.е после первого скрипта появляется второй датасет, который обрабатывается вторым скриптом и т.д). Где хранить датасет? В GITHUB? Кал. Слишком долго будет клонироваться репозиторий + Там ограничение по памяти. В каком-то облаке? Можо. Но если у вас изменился какой-то датасет, то придется ручками его перезаливать и перезапускать скрипты. Ну такое. Решение - DVC. Утилита по управлению кодом и большими файлами данных, которая должна работать в связке с системой управления исходного кода (например, Git). Работа с DVC + Git выглядит примерно так:

![image](https://user-images.githubusercontent.com/57214287/233871119-4a7c5dc9-3299-4ce1-a9ab-48fcfac5e08c.png)

На Github’е хранятся весь ваш код и какие-нибудь метафайлы об имеющихся данных и зависимостях между ними. А в специально выбранном месте (локально или на любом сервере) хранятся данные для обучения, тестирования и т. п.

Также DVC хранит зависимости между скриптами и датасетами. Если у вас изначально был один датасет, и вы решили его как-нибудь обработать, вы можете написать скрипт-обработчик и указать зависимость «скрипт-обработчик и датасет0 формируют датасет1». DVC сам сформирует «датасет1» и начнет его отслеживать. Но самое интересное – цепочки зависимостей: «скрипт0 и датасет0 формируют датасет1», «скрипт1 и датасет1 формируют датасет2» и «скрипт2 и датасет2 формируют файл оценки точности». Файл метрик в этом примере формирует цепочка из 6 файлов. И если хотя бы один из них был изменен в течении работы, достаточно одной команды DVC и все будет заново просчитано по древу зависимостей. Причем, как и утилита Make, DVC отслеживает был ли изменен тот или иной файл.

Вот какие преимущества вам даёт DVC:

1. Абстракция кода от данных;
1. Хранение данных в любом хранилище;
1. Создание пайплайнов по обработке датасетов и их визуализация в консоли;
1. Сохранение и отслеживание всех метрик;
1. Переключение между версиями файлов;
1. Воспроизведение моделей по созданным пайплайнам.

[Подробнее](https://habr.com/ru/articles/535274/#intro)
